This document provides a high-level overview of how the modules in this
package interact.

We start with a Datastore that's created elsewhere in the program. We want to
attach a display to this Datastore; this is the DefaultDisplayWindow.

The DefaultDisplayWindow is primarily responsible for creating all of the
various components of the display:

 * The MMImageCanvas which draws the actual pixels of the image (and which is
   derived from the ImageJ ImageCanvas).
 * The HyperstackControls which provides scrollbars for selecting which 2D
   image plane to display in the canvas, plus some extra controls.
   * The scrollbars (and lock icons, animate icons, etc.) are in ScrollerPanel
 * The MultiModePanel that displays a sidebar of VerticalButtons, each of
   which shows/hides a control panel when toggled.
   * The HistogramsPanel and its corresponding ChannelControlPanel for
     adjusting image contrast
   * The MetadataPanel for displaying summary metadata and per-image
     metadata
   * The CommentsPanel for, naturally, comments
   * The OverlaysPanel for drawing things on top of the image display
   * The DisplaySettingsPanel for other miscellaneous controls
 * An extra Component may be provided to the display by whoever created it,
   which contains custom controls (like the Snap, Start/Stop Live, and Snap to
   Album buttons for the live mode display). These controls are placed beneath
   the HyperstackControls.

Additionally, the DefaultDisplayWindow creates a CanvasUpdateThread, which is
responsible for ensuring that the image shown on the MMImageCanvas is as
up-to-date as possible. It also spawns a DummyImageWindow, which is an
ImageJ StackWindow, so that ImageJ can interact with our data. The
DummyImageWindow is not shown; it serves solely as a proxy to ImageJ.

Interactions with ImageJ are where many complexities arise. ImageJ display
logic is handled by the ImagePlus (for single-channel images) or CompositeImage
(for multi-channel images, and no, you aren't allowed to use a CompositeImage
for single-channel images). The ImagePlus is backed by an ImageStack, which
provides image data; we provide an MMVirtualStack for this.  When told to draw,
the ImagePlus will request images using a flat index, which is translated into
Z, Time, and Channel coordinates (ImageJ doesn't know about any other kind of
coordinate axis). The MMVirtualStack must then request the appropriate image
from the Datastore.  ImageJ does not react well to no such image being
available, which is problematic because it can easily request images that don't
actually exist yet -- in which case we are forced to make something up, or else
risk irrevocably breaking our display. See MMVirtualStack for comments on how
we handle this.

All of these objects (except the Datastore) are tied together using an EventBus
(typically referred to as "displayBus_"). This bus publishes events that are
specific to this display window; there's also a bus associated with the
Datastore, but that is not used for display-centric events. The display bus
processes the following events:

 * PixelsSetEvent: generated by the CanvasUpdateThread, and indicates that it
   has just finished updating the image data for the canvas (though it has not
   been painted to the user's monitor yet). Thus any components (like
   histograms and metadata) that are supposed to be relevant to the
   currently-displayed image must also be updated.
 * FPSEvent: also generated by CanvasUpdateThread, this event provides
   information on how rapidly images are being added to the Datastore, and how
   rapidly the display is being updated. This information in turn is displayed
   by the HyperstackControls as part of its status information.
 * CanvasDrawEvent: generated by MMImageCanvas, and signifies that the canvas
   has finished drawing the pixels it was told to draw (i.e. it's posted at the
   end of the paint() method). The event is consumed by the OverlaysPanel,
   which then gives any active overlays a chance to draw themselves.
 * RequestToCloseEvent: generated by the DefaultDisplayWindow when the user
   clicks on the close button. This is consumed by the "owner" of the
   DefaultDisplayWindow, who needs to give the user a chance to to shut down
   acquisitions, save data, etc. before the display is allowed to go away.
   In most cases the owner will be the DefaultDisplayManager, which owns all
   "tracked" Datastores (see DefaultDisplayManager.track()).
 * LayoutChangedEvent: generated by any of the UI components, and tells the
   DefaultDisplayWindow that it needs to refresh its layout, as components
   have been added, removed, or changed shape.
 * RequestToDrawEvent: generated by any of the UI components, and requests that
   the image canvas be redrawn, possibly to show a different image.
 * StackPositionChangedEvent: generated by MMVirtualStack to indicate that the
   image it is "pointing" at has changed. Consumed by the DummyImageWindow so
   that it can update its scrollbars, which may be relevant to ImageJ code.

Additionally, many of the display components also react to events published
by the Datastore (e.g. when new images arrive or when the display settings
change).
