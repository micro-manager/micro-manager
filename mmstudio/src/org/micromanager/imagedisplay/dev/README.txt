This document provides a high-level overview of how the modules in this
package interact.

We start with a Datastore that's created elsewhere in the program. We want to
attach a display to this Datastore. This is done with the DisplayStarter class,
because we need to ensure there is at least 1 image in the Datastore before
the display is actually created. When the DisplayStarter determines that there
is an image, it creates a DefaultDisplayWindow.

The DefaultDisplayWindow is primarily responsible for creating all of the
various components of the display:

 * The MMImageCanvas which draws the actual pixels of the image.
 * The HyperstackControls which provides scrollbars for selecting which 2D
   image plane to display in the canvas.
 * The MultiModePanel that displays a sidebar of VerticalButtons, each of
   which shows/hides a control panel when toggled.
   * The HistogramsPanel and its corresponding ChannelControlPanel for
     adjusting image contrast
   * The MetadataPanel for displaying summary metadata and per-image
     metadata
   * The CommentsPanel for, naturally, comments
   * The OverlaysPanel for drawing things on top of the image display
   * The DisplaySettingsPanel for other miscellaneous controls

Additionally, it creates a CanvasUpdateThread, which is responsible for
ensuring that the image shown on the MMImageCanvas is as up-to-date as
possible.

It is also responsible for interacting with ImageJ, and this is where many
complexities arise. ImageJ display logic is handled by the ImagePlus (for
single-channel images) or CompositeImage (for multi-channel images, and no
you aren't allowed to use a CompositeImage for single-channel images). The
ImagePlus is backed by an ImageStack; we provide an MMVirtualStack for this.
When told to draw, the ImagePlus will request images using a flat index, which
is translated into Z, Time, and Channel coordinates (ImageJ doesn't know about
any other kind of coordinate axis). The MMVirtualStack must then request the
appropriate image from the Datastore. ImageJ does not react well to no such
image being available, which is problematic because it can easily request
images that don't actually exist yet -- in which case we are forced to make
something up, or else risk irrevocably breaking our display.

All of these objects (except the Datastore) are tied together using an EventBus
(typically referred to as "displayBus_"). This bus publishes events that are
specific to this display window; there's also a bus associated with the
Datastore, but that is not used for display-centric events. The display bus
processes the following events:

 * PixelsSetEvent: generated by the CanvasUpdateThread, and indicates that it
   has just finished updating the canvas display (though it has not been
   painted to the user's monitor yet). Thus any components (like histograms and
   metadata) that are supposed to be relevant to the currently-displayed image
   must also be updated.
 * FPSEvent: also generated by CanvasUpdateThread, this event provides
   information on how rapidly the display is being updated. This information in
   turn is displayed by the HyperstackControls as part of its status
   information.
 * CanvasDrawEvent: generated by MMImageCanvas, and signifies that the canvas
   has finished drawing the pixels it was told to draw (i.e. it's posted at the
   end of the paint() method). The event is consumed by the OverlaysPanel,
   which then gives any active overlays a chance to draw themselves.
 * RequestToCloseEvent: generated by the DefaultDisplayWindow when the user
   clicks on the close button. This is consumed by the "owner" of the
   DefaultDisplayWindow, who needs to give the user a chance to to shut down
   acquisitions, save data, etc. before the display is allowed to go away.
 * LayoutChangedEvent: generated by any of the UI components, and tells the
   DefaultDisplayWindow that it needs to refresh its layout, as components
   have been added, removed, or changed shape.
 * RequestToDrawEvent: generated by any of the UI components, and requests that
   the image canvas be redrawn, possibly to show a different image.

