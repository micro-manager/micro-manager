/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package bidc;

import main.Magellan;

/**
 * Class that wraps raw, double wide, warped buffer to support fast access
 * without having to actually access anything
 * @author henrypinkard
 */
public class RawBufferWrapper {
   
   //set in Bitflow camera file or other A/D converter
    //you dont need any of the first 8 pixels to construct image anyway so tossing them is fine
   private static final int PIXELS_PER_LINE = 1288;
   private static final int LINE_START_THROWAWAY_PIX = 8;
   //-Bitflow must have a at least a 4 pixel difference between the total number of pixels per line and the number of pixels used
   //or else it mistakenly thinks two frames are one
   //number of pixels used must be a multiple of 8
   //mirroring goes away when moving to higher number of pixels per line, and comes back when moving to a lower number of pixels per line
   //but changing number of pixels used doesnt seem to affect it
   
   private static int[] warpedIndicesFromUnwarped_;
   private byte[] buffer_;
   private int offset_;
   private static int unwarpedWidth_;
   private static boolean unwarp_ = true; //for debugging
   
   public RawBufferWrapper(byte[] buffer, int offset, int doubleWidth) {
      if (warpedIndicesFromUnwarped_ == null) {
         warpedIndicesFromUnwarped_ = getCosineWarpLUT();
         unwarpedWidth_ = warpedIndicesFromUnwarped_.length;
      }
      
      offset_ = offset;
      buffer_ = buffer;
     
        //debugging: show double wide, warped iamge
//        ImageStack stack = new ImageStack(doubleWidth, buffer.length / doubleWidth);
//        stack.addSlice(null, buffer);
//        ImagePlus doubleWide = new ImagePlus("double wide", stack);
//        doubleWide.show();
//        doubleWide.close();
    }
   
   public short getUnwarpedImageValue(int x, int y) {
       //this gives you the single wide index in an interlaced image


//       unwarp_ = false;
       int warpedX;
       if (unwarp_) {
           warpedX = warpedIndicesFromUnwarped_[x];
       } else {
           warpedX = x;
       }
//       System.out.println(x + "\t" + warpedX);
       
       if (y % 2 == 1) {
           //take second half of line mirrored
           //x value is double wide with - warped x
           warpedX = (PIXELS_PER_LINE - LINE_START_THROWAWAY_PIX) - warpedX;
           warpedX += (offset_ % 2);
       }

              
        int warpedIndex = Math.max(0,Math.min(buffer_.length - 1, 
                warpedX + (y/2) * (PIXELS_PER_LINE - LINE_START_THROWAWAY_PIX) + offset_ / 2));
        
        return (short) (buffer_[warpedIndex] & 0xff);
    }

   public static int getWidth() {
      if (warpedIndicesFromUnwarped_ == null) {
         warpedIndicesFromUnwarped_ = getCosineWarpLUT();
         unwarpedWidth_ = warpedIndicesFromUnwarped_.length;
      }
      return unwarpedWidth_;
   }
   
   public static int getHeight() {
      //twice the raw image height
      return (int) (Magellan.getCore().getImageHeight() * 2);
   }
   
   /**
    * This function assumes an interlaced, but still warped image its
    * purpose is to generate a pixel LUT with unwarped pixel indices and 
    * warped pixel values
    * Function assumes that number of pixels per line is equal to number of pixels
    * in the double wide image (i.e. no pixels thrown away at start and end of line)
    * 1288 pixels per line to get 410 pixels per image
    */
   public static int[] getCosineWarpLUT() {
      int interlacedWidth = PIXELS_PER_LINE / 2;
      //each pixel corresponds to the same amount of time, but a different amount of space
      //at the very center of the image, there will be a 1-to-1 correpondance of warped
      //pixels and unwarped pixels, at the edges, there will be several unwarped pixels
      //for each warped one
      double radiansPerPix = 2 * Math.PI / (double) PIXELS_PER_LINE;

      int[] unwarpedFromWarped = new int[PIXELS_PER_LINE / 2];

      //find center pixel, i.e. the pixel where distortion is minimized, and 1 pixel
      //in warped image corresponds to one pixel in unwarped image
      //this LUT generated by this function operates on images that have already been deinterlaced.
      //Assuming the offset is correct, the pixelPerLine will start at phase 0 and end at 2pi
      //so the center pixel should be at pi/2
      int centerPixel = PIXELS_PER_LINE / 4 - LINE_START_THROWAWAY_PIX;
      int lutOffset = -1; //used to 0 base indices since theyre calculated form image center
      double[] warpedPixPerPix = new double[interlacedWidth];
      for (int warpedPixIndex = 0; warpedPixIndex < interlacedWidth; warpedPixIndex++) {
         double angle = ((warpedPixIndex+0.5) + LINE_START_THROWAWAY_PIX) * radiansPerPix; //add 0.5 to calculate from center of image
         //represents the relative speed of the mirror at this pixel position
         double relativeSpeedOfMirror = Math.cos(angle - Math.PI / 2);
         //so the inverse of speed is the number of warped pixels per a single pixel in the unwarped image
         warpedPixPerPix[warpedPixIndex] = 1 / relativeSpeedOfMirror;
//         System.out.println(warpedPixPerPix[warpedPixIndex]);
         //correction factor = angular displacemnt / cos(angular displacement - pi/2)
         double displacement = angle - Math.PI/2;
         double correctionFactor = displacement / Math.cos(displacement - Math.PI / 2);
         
//         System.out.println((warpedPixIndex - centerPixel) + "\t" + ((warpedPixIndex - centerPixel) /correctionFactor));
         //make sure lutValues start at 0
         int lutValue = centerPixel + (int)((warpedPixIndex - centerPixel) /correctionFactor); 
         if (lutOffset == -1) {
            lutOffset = lutValue;
         }
         lutValue -= lutOffset;
//         System.out.println( lutValue );
         unwarpedFromWarped[warpedPixIndex] = lutValue;
      }
      //now invert the indices and values of LUT
      
      int[] warpedFromUnwarped = new int[unwarpedFromWarped[unwarpedFromWarped.length-1]+1];
      for (int i = 0; i < warpedFromUnwarped.length; i++) {
         warpedFromUnwarped[i] = getCenterIndexOf(unwarpedFromWarped, i);     
      }
      
      return warpedFromUnwarped;
  }
   
   /**
    * @param array
    * @param val
    * @return the middle index of val in a sorted array with one or more occurrence of val
    */
   public static int getCenterIndexOf(int[] array, int val) {
      int first = -1;
      int last = -1;
      for (int i = 0; i < array.length; i++) {
         if (array[i] == val && first == -1) {
            first = i;
         }
         if (array[i] == val) {
            last = i;
         }
      }
      return (first + last) / 2;
   }
   
}
